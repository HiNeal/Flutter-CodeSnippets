<templateSet group="user">
  <template name="oyquick" value="/**&#10; * Flutter笔记&#10; *&#10; * 1. 一条语句结束使用分号,设置属性之间使用逗号&#10; *&#10; * 2. 有状态的Widget: StatefulWidget 在运行过程中有一些状态(data)需要改变&#10; *    无状态的Widget: StatelessWidget 内容是确定没有状态(data)的改变&#10; *&#10; * 3. 使用StatelessWidget在其中修改组件的状态是有问题的,提示@immutable不可变&#10; *    也就是说在@immutable里面不能出现var,里面必须是final&#10; *&#10; * 4. StatefullWidget: 继承自StatefulWidget的类(可以接收父Widget传过来的数据)/State类(状态)&#10; *    既然StatefulWidget中不能定义状态,我们就创建一个单独的类, 这个类负责维护StatefulWidget的状态&#10; *    我们自己创建的State需要继承State并且支持泛型,传入一个继承于StatefulWidget的泛型&#10; *&#10; * 5. option+enter键可以快速为一个widget添加一个container,padding表示内边距&#10; *    command + option + B就可以找到抽象类的实现类&#10; *    对于Column垂直方向的主轴是mainAxisAlignment,对于Row来说水平方向主轴是crossAxisAlignment&#10; *&#10; * 6. 为什么Flutter在设计的时候StatefulWidget的build方法放在State中&#10; *    1.build出来的Widget是需要依赖State中的变量(状态/数据)&#10; *    2.在Flutter的运行过程中:Widget是不断的销毁和创建的;而当我们自己的状态发生改变时, 并不希望重新状态一个新的State&#10; *&#10; * 7. Widget是不加_: 暴露给别人使用&#10; *    State是加_: 状态这个类只是给Widget使用&#10; *&#10; * 8. 使用child往往是包括单个元素,children往往是多个元素&#10; *&#10; * 9. setState方法可以让我们在里面修改数据外面的View就改变&#10; *    State里面之所以能够拿到widget是因为父类state本身内部就获取了这个属性,一个widget对应一个state&#10; *&#10; *10.执行StatefulWidget的构造函数（Constructor）来创建出StatefulWidget；&#10; *   执行StatefulWidget的createState方法创建一个维护StatefulWidget的State对象；&#10; *   执行State类的构造方法来创建State对象；执行initState，我们通常会在这个方法中执行一些数据初始化的操作，或者也可能会发送网络请求，这个方法是重写父类的方法，必须调用super，因为父类中会进行一些其他操作；&#10; *   执行didChangeDependencies方法，这个方法在两种情况下会调用initState会调用或者从其他对象中依赖一些数据发生改变时，比如前面我们提到的InheritedWidget&#10; *   执行build方法，来看一下我们当前的Widget需要渲染哪些Widget； 当前的Widget不再使用时，会调用dispose进行销毁；&#10; *   手动调用setState方法，会根据最新的状态（数据）来重新调用build方法，构建对应的Widgets； 执行didUpdateWidget方法是在当父Widget触发重建（rebuild）时，系统会调用didUpdateWidget方法；&#10; *   dirty state的含义是实际是通过一个Element的东西 的属性来标记的；将它标记为dirty会等待下一次的重绘检查，强制调用build方法来构建我们的Widget；&#10; *   clean state的含义是干净的State它表示当前build出来的Widget，下一次重绘检查时不需要重新build；&#10; *&#10; * 11. 命令式编程： 命令式编程非常好理解，就是一步步给计算机命令，告诉它我们想做什么事情；&#10; *     声明式编程： 声明式编程通常是描述目标的性质，你应该是什么样的，依赖哪些状态，并且当依赖的状态发生改变时，我们通过某些方式通知目标作出相应；&#10; */" description="Android Studio快捷键" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyshortnote" value="/**&#10; * $MARK$&#10; */" description="注释 - 简单注释" toReformat="false" toShortenFQNames="true">
    <variable name="MARK" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="tnnote" value="/**&#10; * Flutter笔记&#10; *&#10; * 1. 一条语句结束使用分号,设置属性之间使用逗号&#10; *&#10; * 2. 有状态的Widget: StatefulWidget 在运行过程中有一些状态(data)需要改变&#10; *    无状态的Widget: StatelessWidget 内容是确定没有状态(data)的改变&#10; *&#10; * 3. 使用StatelessWidget在其中修改组件的状态是有问题的,提示@immutable不可变&#10; *    也就是说在@immutable里面不能出现var,里面必须是final&#10; *&#10; * 4. StatefullWidget: 继承自StatefulWidget的类(可以接收父Widget传过来的数据)/State类(状态)&#10; *    既然StatefulWidget中不能定义状态,我们就创建一个单独的类, 这个类负责维护StatefulWidget的状态&#10; *    我们自己创建的State需要继承State并且支持泛型,传入一个继承于StatefulWidget的泛型&#10; *&#10; * 5. option+enter键可以快速为一个widget添加一个container,padding表示内边距&#10; *    command + option + B就可以找到抽象类的实现类&#10; *    对于Column垂直方向的主轴是mainAxisAlignment,对于Row来说水平方向主轴是crossAxisAlignment&#10; *&#10; * 6. 为什么Flutter在设计的时候StatefulWidget的build方法放在State中&#10; *    1.build出来的Widget是需要依赖State中的变量(状态/数据)&#10; *    2.在Flutter的运行过程中:Widget是不断的销毁和创建的;而当我们自己的状态发生改变时, 并不希望重新状态一个新的State&#10; *&#10; * 7. Widget是不加_: 暴露给别人使用&#10; *    State是加_: 状态这个类只是给Widget使用&#10; *&#10; * 8. 使用child往往是包括单个元素,children往往是多个元素&#10; *&#10; * 9. setState方法可以让我们在里面修改数据外面的View就改变&#10; *    State里面之所以能够拿到widget是因为父类state本身内部就获取了这个属性,一个widget对应一个state&#10; *&#10; *10.执行StatefulWidget的构造函数（Constructor）来创建出StatefulWidget；&#10; *   执行StatefulWidget的createState方法创建一个维护StatefulWidget的State对象；&#10; *   执行State类的构造方法来创建State对象；执行initState，我们通常会在这个方法中执行一些数据初始化的操作，或者也可能会发送网络请求，这个方法是重写父类的方法，必须调用super，因为父类中会进行一些其他操作；&#10; *   执行didChangeDependencies方法，这个方法在两种情况下会调用initState会调用或者从其他对象中依赖一些数据发生改变时，比如前面我们提到的InheritedWidget&#10; *   执行build方法，来看一下我们当前的Widget需要渲染哪些Widget； 当前的Widget不再使用时，会调用dispose进行销毁；&#10; *   手动调用setState方法，会根据最新的状态（数据）来重新调用build方法，构建对应的Widgets； 执行didUpdateWidget方法是在当父Widget触发重建（rebuild）时，系统会调用didUpdateWidget方法；&#10; *   dirty state的含义是实际是通过一个Element的东西 的属性来标记的；将它标记为dirty会等待下一次的重绘检查，强制调用build方法来构建我们的Widget；&#10; *   clean state的含义是干净的State它表示当前build出来的Widget，下一次重绘检查时不需要重新build；&#10; */" description="Flutter - 笔记" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyexamplefulwidget" value="import 'package:flutter/material.dart';&#10;&#10;main() =&gt; runApp(MyApp());&#10;&#10;class MyApp extends StatelessWidget {&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return MaterialApp(&#10;      home: HYHomePage(),&#10;    );&#10;  }&#10;}&#10;&#10;class HYHomePage extends StatelessWidget {&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(&#10;        title: Text(&quot;商品列表&quot;),&#10;      ),&#10;      body: HYHomeContent(&quot;你好啊,李银河&quot;),&#10;    );&#10;  }&#10;}&#10;&#10;class HYHomeContent extends StatefulWidget {&#10;  final String message;&#10;&#10;  HYHomeContent(this.message);&#10;&#10;  @override&#10;  State&lt;StatefulWidget&gt; createState() {&#10;    return _HYHomeContentState();&#10;  }&#10;}&#10;&#10;class _HYHomeContentState extends State&lt;HYHomeContent&gt; {&#10;  int _counter = 0;&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Center(&#10;      child: Column(&#10;        mainAxisAlignment: MainAxisAlignment.center,&#10;        children: &lt;Widget&gt;[&#10;          _getButtons(),&#10;          Text(&quot;当前计数:$_counter&quot;, style: TextStyle(fontSize: 25),),&#10;          // 这里之所以能够拿到widget是因为父类state本身内部就获取了这个属性,一个widget对应一个state&#10;          Text(&quot;传递的信息:${widget.message}&quot;)&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;&#10;  Widget _getButtons() {&#10;    return Row(&#10;      mainAxisAlignment: MainAxisAlignment.center,&#10;      children: &lt;Widget&gt;[&#10;        RaisedButton(&#10;          child: Text(&quot;+&quot;, style: TextStyle(fontSize: 20, color: Colors.white),),&#10;          color: Colors.pink,&#10;          onPressed: () {&#10;            setState(() {&#10;              _counter++;&#10;            });&#10;          },&#10;        ),&#10;        RaisedButton(&#10;            child: Text(&quot;-&quot;, style: TextStyle(fontSize: 20, color: Colors.white),),&#10;            color: Colors.purple,&#10;            onPressed: () {&#10;              setState(() {&#10;                _counter--;&#10;              });&#10;            }&#10;        ),&#10;      ],&#10;    );&#10;  }&#10;}&#10;" description="例子 - 计数器" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytext" value="    return Text(&#10;      &quot;Hello World&quot;,&#10;      textAlign: TextAlign.center,&#10;      maxLines: 3,&#10;      overflow: TextOverflow.ellipsis,&#10;      textScaleFactor: 1.5,&#10;      style: TextStyle(&#10;          fontSize: 20,&#10;          color: Colors.red,&#10;          fontWeight: FontWeight.bold&#10;      ),&#10;    );&#10;    &#10;    return Text.rich(&#10;      TextSpan(&#10;          children: [&#10;            TextSpan(text: &quot;Hello World&quot;, style: TextStyle(color: Colors.red)),&#10;            TextSpan(text: &quot;Hello flutter&quot;, style: TextStyle(color: Colors.green)),&#10;            WidgetSpan(child: Icon(Icons.favorite, color: Colors.red,)),&#10;            TextSpan(text: &quot;Hello dart&quot;, style: TextStyle(color: Colors.blue)),&#10;          ]&#10;      )&#10;    );" description="Flutter - 文本Widget" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oybutton" value="        FlatButton(&#10;          color: Colors.amberAccent,&#10;          shape: RoundedRectangleBorder(&#10;              borderRadius: BorderRadius.circular(8)&#10;          ),&#10;          child: Row(&#10;            mainAxisSize: MainAxisSize.min,&#10;            children: &lt;Widget&gt;[&#10;              Icon(Icons.favorite, color: Colors.red,),&#10;              Text(&quot;喜欢作者&quot;)&#10;            ],&#10;          ),&#10;          onPressed: () {},&#10;        )" description="界面 - UIButton" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
</templateSet>